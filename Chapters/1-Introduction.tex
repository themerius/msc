\chapter{Einleitung}

\section{Motivation}

Die Erstellung von qualitativ hochwertigen (wissenschaftlichen) Dokumenten ist keine einfache Sache.
Das Computerzeitalter konnte zwar schon viel verbessern, aber es gibt noch
immer Situationen, in denen die Dokumentenerstellung sehr mühselig werden kann.

Zum einen kostet es u.U. sehr viel Zeit, Querreferenzierungen im Dokument zu
pflegen und konsistent zu halten.
Hierfür hat insbesondere LaTeX eine solide Lösung, jedoch stößt man auf der Meta-Ebene
(der LaTeX Code selbst) wieder auf das Problem. Beispiel: Man definiert ein
Label und referenziert an anderen Stellen darauf. Wird das Label irgendwann umbenannt
(weil sich z.B. die Überschrift geändert hat), muss es an allen referenzierten
Stellen auch umbenannt werden (klassisches Refactoring) -- und das geschieht
leider nicht automatisch.

Zum anderen verstehen die Anwendungen oft nur die Domäne „Dokument“,
wenn man z.B. chemische Formeln zeichnen will, müssen diese über externe
Ressourcen hinzugefügt werden. Dabei gibt es keinen wirklichen Zugriff
mehr auf die Meta-Informationen, die eigentlich durch das Domänenmodell
-- die chemische Formel -- mitgeliefert wird. Das kann wiederum zu inkonsistenten
Dokumenten führen. Wenn z.B. nachträglich an der chemischen Formel etwas
geändert wird und nur die Abbildung von Benutzer aktualisiert wurde,
dann sind u.U. die Verweise
(z.B. auf die Masse des chemischen Moleküls)
in den beschreibenden Sätzen nicht mehr korrekt.
Es fehlt das semantische Verständnis seitens des Dokuments, es weiß also nicht,
was die chemische Formel zu bedeuten hat.

Zudem liegt hinter keinem derzeit verfassten Dokument ein echtes/sauberes \emph{Metamodell}.
Das heißt ein Modell, welches eine Struktur vorschreibt, wann welche Dokumentbestandteile
zulässig sind.
Dies kann einen Dokumentenverfasser dabei helfen, ein Dokument (wie z.B. ein Paper der
Fraunhofer Gesellschaft) gemäß definierter Vereinbarungen aufzubauen,
dabei braucht er kein Wissen über die genaue Vereinbarung und kann
dennoch ein formal korrektes Dokument erstellen.
Solche Vereinbarungen können z.B. ein Corporate Design oder eine spezielle Reihenfolge
von Dokumentelementen sein.
Weiterhin kann man ganze Dokumentklassen aus einem solchen Metamodell ableiten;
also all jene Dokumente, welchen das gleiche
Metamodell übergeordnet ist, gehören somit ganz formal zur gleichen Dokumentklasse.
Beispiele für solche Klassen sind: Master-Arbeit, Journal-Paper oder EU-Patent etc.
% Konventionen einer Wissenschaft können hier auch eingebracht werden,
% wie soll welches Element oder Teile davon ausgezeichnet werden,
% oder innerhalb eines Domäneneditors welches Namenskonvention gibt es etc.

\section{Problemstellung}\label{sec.problemstellung}

Aus der Motivation erschließen sich folgende Defizite bzw. Problemfelder in bisherigen Systemen:

\begin{enumerate}[(i)]
  \item Mangel an \emph{Konsistenz}: In bisherigen Textverarbeitungssystemen ist es sehr leicht, Inkostistenzen ins Dokument einzubringen.
  \item Mangel an \emph{Domänenwissen}: Dokumente "verstehen" die Konventionen, Konzepte oder Modelle einer Wissenschaft nicht.
  \item Mangel an \emph{Semantik}: Bedeutungen einzelner Bestandteile eines Dokuments werden oft nicht explizit sichtbar bzw. überhaupt erst verfügbar gemacht.
  \item Mangel an \emph{Metamodellierung}: Es fehlen\footnote{Oder gehen nicht weit genug, wie z.B. im Falle von ~\LaTeX.}\todo{Fußnote: Verweis auf Kapitel wo das erklärt wird, warum latex nicht weit genug geht} formale Vereinbarungen, die eine Dokumentenklasse ausmachen und dem Benutzer bei der Strukturierung helfen.
\end{enumerate}

Das wirft die folgende Frage auf:
\emph{Kann man ein Autorensystem erschaffen,
welches die o.g. Defizite aufhebt?}


\section{Methode}

In erster Linie soll ein Prototyp entwickelt werden, der einen konkreten Lösungsvorschlag
für die Problemstellungen aus Abschnitt \ref{sec.problemstellung} vorlegt.

Da ein Prototyp wunderbar untersucht werden kann, ist es möglich, theoretische Ideen
besser zu veranschaulichen oder überhaupt erst greifbar zu machen.
Zudem können unterschiedliche Anwendungsfälle demonstiert werden, um potentiellen Interessenten
dieser Technologie Anschauungsmaterial zu liefern.

Die Entwicklung eines Protoypen macht bei dieser Masterarbeit Sinn, da am Prototypen:

\begin{itemize}
  \item theoretische Konzepte aufgezeigt und empirisch validiert\footnote{Funktioniert das Konzept richtig?} werden können, und
  \item leicht Anwendungsfälle ausprobiert werden können, um die praktische Tauglichkeit der Softwarearchitektur zu verifizieren\footnote{Ist das System richtig gebaut?}.
\end{itemize}

\section{Anforderungen}

Bei den Anforderungen an den Prototypen kann man schon
konkreter in Richtung Implementierung blicken.

Um die Problemstellungen zu lösen:

Die kleinste Einheit im System ist das \emph{Dokumentenelement}.
Beispiele für Dokumentenelemente sind: Abschnitte, Absätze, Tabellen, Abbildungen, Fußnoten, etc.
\todo{Im Abschnitt "Modelle" den Begriff genauer def und unterteilen -> REF hier her.}

Dokumentelemente sollen in der Lage sein, konkretes "lebendinges" Domänenwissen zu beinhalten.
Das heißt, dass z.B. eine Zeichnung eines chemischen Moleküls im Hintergrund tatsächlich
auf einem formalen Molekülmodell basiert.

Reichhaltige Verweisungen unter den Dokumentelementen sollen möglich sein.
Das heißt, dass z.B. das formale Modell des Moleküls
anderen Dokumentelementen weitere (u.U. berechnete) Informationen bereitstellen kann.

Ein Metamodell definiert die im Dokument vorkommenden Dokumentelemente formal.
Das Dokument selbst soll folglich als Modell (Instanz) aufgefasst werden.

Um die Software benutzbar zu machen:\todo{Besser? Weiche oder Zusatz Anforderungen? Nebenbedingungen / Benutzbarkeit / Bequemlichkeitsfunktionen.}

\begin{itemize}
  \item Es soll ein reaktives System sein, welches sofort auf Eingaben des Benutzers bzw. Veränderungen des Systemzustands reagiert.
  \item Es soll also ein "lebendiges" Dokument werden, d.h. es sollen keine (spürbaren) Kompilierzeiten um das Dokument zu erstellen entstehen.
  \item Da es in wissenschaftlichen Dokumenten meist zu komplizierten Verweisungen kommt, müssen diese in jedem Fall konsistent gehalten werden. Es soll daher das Verweisvariablen-Refacotring-Problem\todo{Unschönes Wort!} abgefedert werden.
  \item Es soll ein einheimischer des WWW werden, d.h. Web Standards sind das Ausgabeformet. Sie übernehmen das Setzen des Dokuments, bieten dem Benutzer eine Editierschnittstelle, ermöglichen Kollaboration und bieten eine ubiquitäre Wissensrepräsentation.
\end{itemize}

Durch einige diese Anforderungen gewinnen wir implizit einen Projektionseditor und
sogar Potential für ein Dokument "Query Interface"\todo{REF zum entspr Kapitel mit Erklärung}

\section{Idee}

% Idee gesucht um BSc weiterzuentwickeln -> Vorlesung 1. master sem -> MPS/mbeddr -> Projectional Editing. http://confluence.jetbrains.com/display/MPSD31/FAQ
% Und so entwickelten sich diese überlegungen...

Im Vordergrund stand die Idee meine Bachelorarbeit so weiter zu entwickeln, dass Dokumente
in einem Struktureditor oder Projektionseditor\todo{REF auf Kapitel das ProjEdit genauer erklärt} verfasst werden können und mit domänenspezifischen Dokumentelementen
interagiert werden kann.

In diesem Kapitel wird also kurz die prinzipielle Idee umrissen,
wie man die Problemstellung unter den gegebenen Anforderungen lösen könnte.

Grundsatz der Idee ist dass jedes Dokumentelement auf ein Aktor abgebildet wird.
Ein Aktor kann Nachrichten senden und empfangen, zudem kapselt er einen Zustand und ein Verhalten.

Aktoren können, ebenso wie ein Dokument, hierarchisch angeornet werden.
Das heißt ein Aktor kann Kinder und Geschwister haben.
Diese Anordnung ergibt eine baumartige Graphenstruktur, worin ein Aktor
einem Knoten entspricht und eine Referenz\footnote{Über eine solche Aktor Referenz können Nachrichten an andere Aktoren übermittelt werden.} auf einen anderen Aktor eine Kante.

Diese Baumstruktur kann als \emph{abstrakter Syntaxbaum}\footnote{
Englisch: abstract syntax tree. Kurzschreibweise: AST.} (AST) der Dokumentenstruktur aufgefasst werden.
Der AST kann als ein Modell für ein Dokument aufgefasst werden.
Dies wird auf Abbildung \ref{fig.idee} veranschaulicht.
Zudem kann mit Hilfe eines AST ein Struktureditor umgesetzt werden\todo{REF zu Begründungskaptiel}.
Der hier mit den Aktoren umgesetzte AST könnte als "reaktiver AST" bezeichnet werden,
da er dank der Aktoren (quasi gratis) besondere Eigenschaften erhält:

\begin{itemize}
  \item Verteilbarkeit, Fehlertoleranz und massive Parallelität.\\
        AST kann z.B. auf ein Cluster gebracht werden, z.B. zur Kompilierung des Dokuments in "der Cloud"; Anwendung von MapReduce auf Dokument oder Dokumentenserie; Jeder Aktor ist autonom, d.h. z.B. asynchrone Datanbankzugriffe oder schnelle Reaktionszeiten auf Änderungen.
  \item Möglichkeit zum Query Interafce ausgebaut zu werden.\\
        Das Dokument bzw. Dokumentelement kann auf Nachrichten reagieren. Beispielsweise zur Aggregation neuer Informationen.
  \item Möglichkeit mit anderen (Aktoren-) Systemen (z.B. Dokumenten) zu interagieren.\\
        Beispielsweise via Akka Remoting Protokoll oder Anbindung an REST-Schnittstellen.
\end{itemize}

\fig{idee}{Modell für ein Dokument. Jeder Aktor (Raute) repräsentiert ein Dokumentelement.
Die Aktoren kennen sich (graue Pfeile) und spannen somit einen Graphen auf.
Die Aktoren können Nachrichten (grüne Pfeile) austauschen, z.B. um Benummerungen aufzulösen.}

\subsection{Szenario}

\section{Frangen von wissenschaftlichem Interesse}

Können Aktoren ein als AST eingesetzt werden?
Was ergibt sich daraus? Architekturell? Was ergibt das für Vor- und Nachteile?
  - Projektions Editoren (wie macht das MPS?)
  - Code Generatoren

Metamodelle in Dokumenten und das Dokument als Modell, macht das Sinn?
  - Gibt es ein Metametamodell?
  - Die "was ist zugelassen Matrix"?
  - Lassen sich Dokumente verifizieren?
  - Anbindung der domänenspezifischen Editoren

Brauchen wir mehr explizite Semantik? Was ist der Vorteil wenn sie direkt
vom Autor transportiert wird? (Und das Dokument / der Editor helfen dabei
um diesen Vorgang zu erleichtern)
  - Verifizierbare Dokumente? Das Dokument kann sich in gewisser Weise selbst verifizieren?
  - Konsistentere Dokumente?

Wo siedelt sich das neue Autorensystem an? (Zwischen Latex und Word?)

Was sind wiss. Dokumente?
  - Sprache == API für Knowledge
  - Wiss. Dokumente erweitern das Wissensgebiet
  - Wiss. Dokumente arbeiten selbst immer mit Modellen (allg. Modelltheorie)
  - Allgemeine Taxonomie wissenschaftlicher Publikationen

Anwendungsfälle / Use Cases. Ist die Editorarchitektur so flexibel um in den
verschiedensten Szenarien funktionierende, fast schon maßgeschneiderte Lösungen
anzubieten?
  - Warum ist es für Spray ein ideales Dokumentationswerkzeug?
  - Darstellung und Editierung von UIMA CAS Dokumenten (Annotationen)
  - ...?


% --------------

\chapter{Theorie}

Hier werden theoretische Konzepte erarbeitet.

\section{Modell und Metamodell}

Insbesondere in Bezug auf Dokumente

\section{Semiotik: Syntax, Semantik, Pragmatik, Sigmatik}

\subsection{Domäneneditoren}

\section{Abstrakter Syntaxbaum}

Hier sowas wie "Reactive Abstract Syntax Tree Interface Definition"?

\section{Dokumentstruktur Matrix}

\section{Ontologie/Taxonomie wissenschaftlicher Publikationen}

\section{Struktureditoren}

Oder ist das eine Technologie?
Struktureditoren oder Projektionseditoren oder projectional editors...

\fig{parser-vs-projectional}{\emph{Parserbasierte Editierung} (links) verglichen mit \emph{projektionsbasierter Editierung} (rechts). Grafiken aus \citep{voelter} entnommen.}


\chapter{Anwendungsfälle}



\citep{default}

Test $123$ \citep{6902013}

Man kann sich das vorstellen wie LaTeX mit on the fly compile,
mit interaktive Bearbeitung durch den Nutzer des Dokuments im Web ala
Google Docs, in Verbindung mit verschiedenen Programmiersprachen
die zusammen kooperieren können, um dynamische Inhalte zu erzeugen,
welche wiederum an verschiedene domänenspezifische Editoren angebunden sind.

Szenarien die laufen sollen:

(1) Anbindung an UIMA, d.h. Elemente müssen als Annotation gekennzeichnet sein
und auch editierbar.
(2) Es ist möglich Spray Modelle mit dem System du dokumentieren.
(3) Eventuell: Diese Masterarbeit damit verfasst, zeigt die Tauglichkeit
auch für wissenschaftliche Texte.

All das mit möglichst viel Semantik dahinter.

\chapter{Grundlagen, Grundbegriffe und Technologien}

\section{Semantik}

\begin{quote}Semantik [...] nennt man die Theorie oder Wissenschaft von der Bedeutung der Zeichen.
Zeichen können in diesem Fall Wörter, Phrasen oder Symbole sein. Die Semantik beschäftigt sich 
typischerweise mit den Beziehungen zwischen den Zeichen und den Bedeutungen dieser Zeichen.
\end{quote}
\url{http://de.wikipedia.org/wiki/Semantik}

\begin{quote}Formale Semantik beschäftigt sich mit der exakten Bedeutung von künstlichen
oder natürlichen Sprachen. Dabei kann sowohl die Bedeutung bestehender Sprachen untersucht
als auch die Bedeutung neu geschaffener Sprachen festgelegt werden.
In Abgrenzung zur Semantik im allgemeinen Sinn, wie sie vor allem in Philosophie und Linguistik
betrieben wird, arbeitet die formale Semantik mit rein formalen, logisch-mathematischen Methoden.
\end{quote}
\url{http://de.wikipedia.org/wiki/Formale_Semantik}

\begin{quote}Die semantische Analyse überprüft die statische Semantik,
also über die syntaktische Analyse hinausgehende Bedingungen an das Programm.
Zum Beispiel muss eine Variable in der Regel deklariert worden sein, bevor sie verwendet wird,
und Zuweisungen müssen mit kompatiblen (verträglichen) Datentypen erfolgen.
\end{quote}
\url{http://de.wikipedia.org/wiki/Compiler#Semantische_Analyse}

\begin{quote}Das Semantische Web [...] ist ein Konzept bei der Entwicklung des World Wide Webs und des 
Internets. [...] All die in menschlicher Sprache ausgedrückten Informationen im Internet sollen mit
einer eindeutigen Beschreibung ihrer Bedeutung (Semantik) versehen werden, die auch von Computern 
verstanden oder zumindest verarbeitet werden kann. Die maschinelle Verwendung der Daten aus dem von 
Menschen geflochtenen Netz der Daten ist nur möglich, wenn die Maschinen deren Bedeutung eindeutig 
zuordnen können; nur dann stellen sie Informationen dar.
\end{quote}
\url{http://de.wikipedia.org/wiki/Semantisches_Web}

Wenn in dieser Arbeit von \emph{der Semantik} gesprochen wird, ist die Zuweisung einer
exakten Bedeutung zu einem Objekt gemeint.

\section{Taxonomie wissenschaftlicher Publikationen}

Neben Gestaltungsregeln, soll hier auch ein Thesaurus zu finden sein.
DIN Normen, DocBook, Buchwissenschaft sollen als Grundlage dienen.
Daraus soll dann in einem extra Kapitel ein Metamodell für wiss. Dokumente
entstehen.

Auch auf die Normseite eingehen: http://de.wikipedia.org/wiki/Normseite

\subsection{Glossar}

Ein alphabetisch sortiertes Glossar über die einzelnen Dokumentbestandteile.

\begin{multicols}{2}
  \begin{description}
    \item[abstract, Abstract, Kurzreferat]
    Ein Abstract ist definiert als eine gekürzte präzise Darstellung des Inhalts eines Dokuments. (ANSI)
  \end{description}
\end{multicols}

\subsection{Hierarchie}

In englisch könnte man \emph{Dokumentbestandteile Hierarchie} als
\emph{document element hierachy} bezeichnen?

Da die Begriffe zum einen Teil aus deutschen und zum anderen Teil aus englischen Quellen
stammen, werden hier immer nach Möglichkeit beide Begriffe aufgelistet.
Die deutschen Begriffe stammen insbesondere aus TODO(Referenzen) DIN/Buchlexika,
die englischen Begriffe insbesondere aus TODO(Referenzen) DoCO.
Die englischen Begriffe sind für die Implementierung relevant und daher zuerst aufgelistet.

Contraints werden der Einfachheit halber in eckigen Klammern angegeben.

\subsubsection{container element (Behälter Bestandteile)}

\input{Chapters/container_element}

\subsubsection{meta element (Meta Bestandteile)}

\input{Chapters/meta_element}

\subsubsection{structure element (Struktur Bestandteile)}

\input{Chapters/structure_element}

\section{Aktoren}

Was sind Aktoren?

Es gibt einige Scala Aktoren Frameworks: Vorstellen und kleiner Vergleich?
Performanz? Features?

Ein paar Worte zu TestKit. Verweis auf MWE in Appendix?


\section{Domäneneditoren}

Hier exemplarisch eingesetzte Editoren. Hinweis: Es könnten noch mehr
Editoren implementiert werden

\subsection{Spray}

Kurze Einführung zu Spray und deren Webkomponente und wie diese hier genutzt
wird.

\subsection{Ketcher}

...


\section{UIMA}

Was ist das und wie kommt es hier zum Einsatz.


\section{Auswahl des Serverframeworks}                         \label{sec.server}

Alle Frameworks werden noch aktiv entwickelt und gepflegt.

Untersuchte Scala Frameworks:

Spray.io Version 1.2.0
Unterstützt keine Websockets, ist erst für die Zukunft geplant.
Entwickelt seit 2011. (siehe Changelog)
Im Hintergrund (als Server) läuft pures Akka?
\url{http://spray.io/}

Play Framework Version Version 2.2.2
Sehr vielversprechend und stabil mit großer Entwicklergemeinde.
Jedoch läuft der Scala Interpreter hier nicht, da eine extra VM gestartet
wird, was durch das play sbt plugin geschuldet ist.
Entwickelt seit 2007. (Wikipedia - besser Quelle suchen)
Im Hintergrund läuft JBoss Netty.
\url{http://www.playframework.com/}

Socko Web Server Version 0.4.1
Interessante Funktionen, aber für mich eine schwierige und umständliche API.
Entwickelt seit 2012? (Nur ungefährt aus Github Version 0.1)
Im Hintergrund läuft JBoss Netty.
\url{http://sockoweb.org/}

Xiturm Version 3.5
Mit Abstand die beste und schönste API und wird schon seit 2010 aktiv entwickelt.
Wird laut Author in echten Projekten schon erfolgreich eingesetzt.
Die Dokumentation ist auch recht umfangreich und gut verständlich.
Im Hintergrund läuft JBoss Netty.
\url{http://ngocdaothanh.github.io/xitrum/}
About: \url{https://groups.google.com/forum/#!topic/xitrum-framework/Jx6bwGciNR0}

% --------------------------------------------------------------- end sec.server


\chapter{Entwicklung des Prototypen}


\section{Basiskonzepte}

\subsection{Referenzierungen}

Referenzierungen angereichert mit (Programmcode) Ausdrücken.
Expression returnt eine Scala Klasse auf die toString angewendet wurde,
aber diese Klasse kann auch ihren Typ verraten so dass dieser direkt
als Annotation der Referenz verwendet werden kann.

2 Modelle:

(1) Aktor hat content String mit Code (Expression) der zu Aktor-Referenzen zeigt

(2) Aktor hat Kind-Aktoren als "content" und die Kinder enthalten Code-Expressions
    oder reinen Text.

UMIA zu Scaltex:
zu (1): Wenn Text gefunden einfach an content anhängen, wenn spezielle
Annotation gefunden dann entsprechenden Aktor erstellen (unsichtbar) und
eine \verb|${ Aktor-UUID.gewünschte_repräsentation}| darauf erstellen und an
den content-String anhängen.


\section{Verwendete Technologien}

html5: contenteditable

\subsection{Ketcher}

\subsection{Spray}

\subsection{UIMA}

\subsection{Akka Toolkit}

\subsection{Xitrum Toolkit}


\section{Abstrakter Syntax Baum}

Jeder Knoten im AST ist ein Aktor. Der AST entspricht einem gerichteten Graph.
Zeigen, dass es ein Baum-Graph ist!

\url{http://de.wikipedia.org/wiki/Abstract_Syntax_Tree}


\subsection{Algorithmus: Aufdecken der Kapitel Benummerung im gerichteten Graph}

Aufdecken der Section Nummern im gerichteten Graph.

Gerichteter Graph G: a -> b -> x -> c
a,b,c sind Sections
x ist keine Section
N = Knoten
E = Kanten

a schickt die Nachricht "Durchzählen(1)" durch G.

b erhält eine Nachricht von a.
b erhöht Durchzählen um 1 auf Durchzählen(2).
b setzt seinen eigenen Nummerzähler auf Durchzählen(2).
b schickt "Druchzählen(2)" weiter durch den Graph.

x reicht die "Durchzählen" Nachricht weiter, ohne Aktion.

c erhält eine Nachricht die von a und b (etc.) bearbeitet wurden.
c erhöht Durchzählen um 1 auf Durchzählen(3)
c setzt seinen eigenen Nummerzähler auf Durchzählen(3).
Da c keinen Nachfolger mehr hat, kann nichts weitergeleitet werden.

Damit werden maximal |E| Nachrichten benötigt, um für jeden Section Knoten
die korrekte Nummer zu bestimmen.


Bei SubSection und SubSubSection einfach mit der
Nachricht Durchzählen(1, true, 1, false, 1, false) beginnen.
Wobei die Boolwerte anzeigen, welcher Wert zuletzt aktualisiert wurde.
So kann jede SubSection oder SubSubSection herausfinden, zu welcher
übergeordneten Section/SubSection sie gehört.

a ! Durchzählen(1, true, 1, false, 1, false)
b ! Durchzählen(2, true, 1, false, 1, false)
aa ! Durchzählen(2, false, 1, true, 1, false)
bb ! Durchzählen(2, false, 2, true, 1, false)
aaa ! Durchzählen(2, false, 2, false, 1, true)
bbb ! Durchzählen(2, false, 2, false, 2, true)
c ! Durchzählen(3, true, 1, false, 1, false)
...

Das ist ein recht natürlicher Ansatz, um die Nummerierungen zu bestimmen.
Auf diese Art können Section, SubSection und SubSubSection gleichzeitig
mit einer einzigen Nachrichtenkette aktualisiert werden.
Der Aufwand bleibt also bei maximal |E| Nachrichten.


\chapter{Ergebnisse und Analyse}

\section{Validierung der theoretischen Konzepte}

\section{Verifikation der Anwendungsfälle}

\chapter{Fazit}


\chapter{Ausblick}


% http://tex.stackexchange.com/questions/49643/making-appendix-for-thesis
