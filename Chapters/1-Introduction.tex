\chapter{Einleitung}

\citep{default}

Test $123$ \citep{6902013}

Man kann sich das vorstellen wie LaTeX mit on the fly compile,
mit interaktive Bearbeitung durch den Nutzer des Dokuments im Web ala
Google Docs, in Verbindung mit verschiedenen Programmiersprachen
die zusammen kooperieren können, um dynamische Inhalte zu erzeugen,
welche wiederum an verschiedene domänenspezifische Editoren angebunden sind.

\chapter{Grundlagen, Grundbegriffe und Technologien}

\section{Semantik}

\begin{quote}Semantik [...] nennt man die Theorie oder Wissenschaft von der Bedeutung der Zeichen.
Zeichen können in diesem Fall Wörter, Phrasen oder Symbole sein. Die Semantik beschäftigt sich 
typischerweise mit den Beziehungen zwischen den Zeichen und den Bedeutungen dieser Zeichen.
\end{quote}
\url{http://de.wikipedia.org/wiki/Semantik}

\begin{quote}Formale Semantik beschäftigt sich mit der exakten Bedeutung von künstlichen
oder natürlichen Sprachen. Dabei kann sowohl die Bedeutung bestehender Sprachen untersucht
als auch die Bedeutung neu geschaffener Sprachen festgelegt werden.
In Abgrenzung zur Semantik im allgemeinen Sinn, wie sie vor allem in Philosophie und Linguistik
betrieben wird, arbeitet die formale Semantik mit rein formalen, logisch-mathematischen Methoden.
\end{quote}
\url{http://de.wikipedia.org/wiki/Formale_Semantik}

\begin{quote}Die semantische Analyse überprüft die statische Semantik,
also über die syntaktische Analyse hinausgehende Bedingungen an das Programm.
Zum Beispiel muss eine Variable in der Regel deklariert worden sein, bevor sie verwendet wird,
und Zuweisungen müssen mit kompatiblen (verträglichen) Datentypen erfolgen.
\end{quote}
\url{http://de.wikipedia.org/wiki/Compiler#Semantische_Analyse}

\begin{quote}Das Semantische Web [...] ist ein Konzept bei der Entwicklung des World Wide Webs und des 
Internets. [...] All die in menschlicher Sprache ausgedrückten Informationen im Internet sollen mit
einer eindeutigen Beschreibung ihrer Bedeutung (Semantik) versehen werden, die auch von Computern 
verstanden oder zumindest verarbeitet werden kann. Die maschinelle Verwendung der Daten aus dem von 
Menschen geflochtenen Netz der Daten ist nur möglich, wenn die Maschinen deren Bedeutung eindeutig 
zuordnen können; nur dann stellen sie Informationen dar.
\end{quote}
\url{http://de.wikipedia.org/wiki/Semantisches_Web}

Wenn in dieser Arbeit von \emph{der Semantik} gesprochen wird, ist die Zuweisung einer
exakten Bedeutung zu einem Objekt gemeint.

\section{Taxonomie wissenschaftlicher Publikationen}

Neben Gestaltungsregeln, soll hier auch ein Thesaurus zu finden sein.
DIN Normen, DocBook, Buchwissenschaft sollen als Grundlage dienen.
Daraus soll dann in einem extra Kapitel ein Metamodell für wiss. Dokumente
entstehen.

Auch auf die Normseite eingehen: http://de.wikipedia.org/wiki/Normseite

\subsection{Glossar}

Ein alphabetisch sortiertes Glossar über die einzelnen Dokumentbestandteile.

\begin{multicols}{2}
  \begin{description}
    \item[abstract, Abstract, Kurzreferat]
    Ein Abstract ist definiert als eine gekürzte präzise Darstellung des Inhalts eines Dokuments. (ANSI)
  \end{description}
\end{multicols}

\subsection{Hierarchie}

In englisch könnte man \emph{Dokumentbestandteile Hierarchie} als
\emph{document element hierachy} bezeichnen?

Da die Begriffe zum einen Teil aus deutschen und zum anderen Teil aus englischen Quellen
stammen, werden hier immer nach Möglichkeit beide Begriffe aufgelistet.
Die deutschen Begriffe stammen insbesondere aus TODO(Referenzen) DIN/Buchlexika,
die englischen Begriffe insbesondere aus TODO(Referenzen) DoCO.
Die englischen Begriffe sind für die Implementierung relevant und daher zuerst aufgelistet.

Contraints werden der Einfachheit halber in eckigen Klammern angegeben.

\subsubsection{container element (Behälter Bestandteile)}

\input{Chapters/container_element}

\subsubsection{meta element (Meta Bestandteile)}

\input{Chapters/meta_element}

\subsubsection{structure element (Struktur Bestandteile)}

\input{Chapters/structure_element}

\section{Aktoren}

Was sind Aktoren?

Es gibt einige Scala Aktoren Frameworks: Vorstellen und kleiner Vergleich?
Performanz? Features?

Ein paar Worte zu TestKit. Verweis auf MWE in Appendix?


\section{Domäneneditoren}

Hier exemplarisch eingesetzte Editoren. Hinweis: Es könnten noch mehr
Editoren implementiert werden

\subsection{Spray}

Kurze Einführung zu Spray und deren Webkomponente und wie diese hier genutzt
wird.

\subsection{Ketcher}

...


\section{UIMA}

Was ist das und wie kommt es hier zum Einsatz.


\section{Auswahl des Serverframeworks}                         \label{sec.server}

Alle Frameworks werden noch aktiv entwickelt und gepflegt.

Untersuchte Scala Frameworks:

Spray.io Version 1.2.0
Unterstützt keine Websockets, ist erst für die Zukunft geplant.
Entwickelt seit 2011. (siehe Changelog)
Im Hintergrund (als Server) läuft pures Akka?
\url{http://spray.io/}

Play Framework Version Version 2.2.2
Sehr vielversprechend und stabil mit großer Entwicklergemeinde.
Jedoch läuft der Scala Interpreter hier nicht, da eine extra VM gestartet
wird, was durch das play sbt plugin geschuldet ist.
Entwickelt seit 2007. (Wikipedia - besser Quelle suchen)
Im Hintergrund läuft JBoss Netty.
\url{http://www.playframework.com/}

Socko Web Server Version 0.4.1
Interessante Funktionen, aber für mich eine schwierige und umständliche API.
Entwickelt seit 2012? (Nur ungefährt aus Github Version 0.1)
Im Hintergrund läuft JBoss Netty.
\url{http://sockoweb.org/}

Xiturm Version 3.5
Mit Abstand die beste und schönste API und wird schon seit 2010 aktiv entwickelt.
Wird laut Author in echten Projekten schon erfolgreich eingesetzt.
Die Dokumentation ist auch recht umfangreich und gut verständlich.
Im Hintergrund läuft JBoss Netty.
\url{http://ngocdaothanh.github.io/xitrum/}
About: \url{https://groups.google.com/forum/#!topic/xitrum-framework/Jx6bwGciNR0}

% --------------------------------------------------------------- end sec.server


\chapter{Entwicklung des Prototypen}


\section{Abstrakter Syntax Baum}

Jeder Knoten im AST ist ein Aktor. Der AST entspricht einem gerichteten Graph.
Zeigen, dass es ein Baum-Graph ist!

\url{http://de.wikipedia.org/wiki/Abstract_Syntax_Tree}


\subsection{Algorithmus: Aufdecken der Kapitel Benummerung im gerichteten Graph}

Aufdecken der Section Nummern im gerichteten Graph.

Gerichteter Graph G: a -> b -> x -> c
a,b,c sind Sections
x ist keine Section
N = Knoten
E = Kanten

a schickt die Nachricht "Durchzählen(1)" durch G.

b erhält eine Nachricht von a.
b erhöht Durchzählen um 1 auf Durchzählen(2).
b setzt seinen eigenen Nummerzähler auf Durchzählen(2).
b schickt "Druchzählen(2)" weiter durch den Graph.

x reicht die "Durchzählen" Nachricht weiter, ohne Aktion.

c erhält eine Nachricht die von a und b (etc.) bearbeitet wurden.
c erhöht Durchzählen um 1 auf Durchzählen(3)
c setzt seinen eigenen Nummerzähler auf Durchzählen(3).
Da c keinen Nachfolger mehr hat, kann nichts weitergeleitet werden.

Damit werden maximal |E| Nachrichten benötigt, um für jeden Section Knoten
die korrekte Nummer zu bestimmen.


Bei SubSection und SubSubSection einfach mit der
Nachricht Durchzählen(1, true, 1, false, 1, false) beginnen.
Wobei die Boolwerte anzeigen, welcher Wert zuletzt aktualisiert wurde.
So kann jede SubSection oder SubSubSection herausfinden, zu welcher
übergeordneten Section/SubSection sie gehört.

a ! Durchzählen(1, true, 1, false, 1, false)
b ! Durchzählen(2, true, 1, false, 1, false)
aa ! Durchzählen(2, false, 1, true, 1, false)
bb ! Durchzählen(2, false, 2, true, 1, false)
aaa ! Durchzählen(2, false, 2, false, 1, true)
bbb ! Durchzählen(2, false, 2, false, 2, true)
c ! Durchzählen(3, true, 1, false, 1, false)
...

Das ist ein recht natürlicher Ansatz, um die Nummerierungen zu bestimmen.
Auf diese Art können Section, SubSection und SubSubSection gleichzeitig
mit einer einzigen Nachrichtenkette aktualisiert werden.
Der Aufwand bleibt also bei maximal |E| Nachrichten.


\chapter{Ergebnisse und Analyse}


\chapter{Fazit}


\chapter{Ausblick}


% http://tex.stackexchange.com/questions/49643/making-appendix-for-thesis
