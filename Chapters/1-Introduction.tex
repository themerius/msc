\chapter{Einleitung}

\section{Motivation}

Die Erstellung von qualitativ hochwertigen (wissenschaftlichen) Dokumenten ist keine einfache Sache.
Das Computerzeitalter konnte zwar schon viel verbessern, aber es gibt noch
immer Situationen, in denen die Dokumentenerstellung sehr mühselig werden kann.

Zum einen kostet es u.U. sehr viel Zeit, Querreferenzierungen im Dokument zu
pflegen und konsistent zu halten.
Hierfür hat insbesondere LaTeX eine solide Lösung, jedoch stößt man auf der Meta-Ebene
(der LaTeX Code selbst) wieder auf das Problem. Beispiel: Man definiert ein
Label und referenziert an anderen Stellen darauf. Wird das Label irgendwann umbenannt
(weil sich z.B. die Überschrift geändert hat), muss es an allen referenzierten
Stellen auch umbenannt werden (klassisches Refactoring) -- und das geschieht
leider nicht automatisch.

Zum anderen verstehen die Anwendungen oft nur die Domäne „Dokument“,
wenn man z.B. chemische Formeln zeichnen will, müssen diese über externe
Ressourcen hinzugefügt werden. Dabei gibt es keinen wirklichen Zugriff
mehr auf die Meta-Informationen, die eigentlich durch das Domänenmodell
-- die chemische Formel -- mitgeliefert wird. Das kann wiederum zu inkonsistenten
Dokumenten führen. Wenn z.B. nachträglich an der chemischen Formel etwas
geändert wird und nur die Abbildung von Benutzer aktualisiert wurde,
dann sind u.U. die Verweise
(z.B. auf die Masse des chemischen Moleküls)
in den beschreibenden Sätzen nicht mehr korrekt.
Es fehlt das semantische Verständnis seitens des Dokuments, es weiß also nicht,
was die chemische Formel zu bedeuten hat.

Zudem liegt hinter keinem derzeit verfassten Dokument ein echtes/sauberes \emph{Metamodell}.
Das heißt ein Modell, welches eine Struktur vorschreibt, wann welche Dokumentbestandteile
zulässig sind.
Dies kann einen Dokumentenverfasser dabei helfen, ein Dokument (wie z.B. ein Paper der
Fraunhofer Gesellschaft) gemäß definierter Vereinbarungen aufzubauen,
dabei braucht er kein Wissen über die genaue Vereinbarung und kann
dennoch ein formal korrektes Dokument erstellen.
Solche Vereinbarungen können z.B. ein Corporate Design oder eine spezielle Reihenfolge
von Dokumentelementen sein.
Weiterhin kann man ganze Dokumentklassen aus einem solchen Metamodell ableiten;
also all jene Dokumente, welchen das gleiche
Metamodell übergeordnet ist, gehören somit ganz formal zur gleichen Dokumentklasse.
Beispiele für solche Klassen sind: Master-Arbeit, Journal-Paper oder EU-Patent etc.
% Konventionen einer Wissenschaft können hier auch eingebracht werden,
% wie soll welches Element oder Teile davon ausgezeichnet werden,
% oder innerhalb eines Domäneneditors welches Namenskonvention gibt es etc.

\section{Problemstellung}\label{sec.problemstellung}

Aus der Motivation erschließen sich folgende Defizite bzw. Problemfelder in bisherigen Systemen:

\begin{enumerate}[(i)]
  \item Mangel an \emph{Konsistenz}: In bisherigen Textverarbeitungssystemen ist es sehr leicht, Inkostistenzen ins Dokument einzubringen.
  \item Mangel an \emph{Domänenwissen}: Dokumente "verstehen" die Konventionen, Konzepte oder Modelle einer Wissenschaft nicht.
  \item Mangel an \emph{Semantik}: Bedeutungen einzelner Bestandteile eines Dokuments werden oft nicht explizit sichtbar bzw. überhaupt erst verfügbar gemacht.
  \item Mangel an \emph{Metamodellierung}: Es fehlen\footnote{Oder gehen nicht weit genug, wie z.B. im Falle von ~\LaTeX.}\todo{Fußnote: Verweis auf Kapitel wo das erklärt wird, warum latex nicht weit genug geht} formale Vereinbarungen, die eine Dokumentenklasse ausmachen und dem Benutzer bei der Strukturierung helfen.
\end{enumerate}

Das wirft die folgende Frage auf:
\emph{Kann man ein Autorensystem erschaffen,
welches die o.g. Defizite aufhebt?}


\section{Methode}

In erster Linie soll ein Prototyp entwickelt werden, der einen konkreten Lösungsvorschlag
für die Problemstellungen aus Abschnitt \ref{sec.problemstellung} vorlegt.

Da ein Prototyp wunderbar untersucht werden kann, ist es möglich, theoretische Ideen
besser zu veranschaulichen oder überhaupt erst greifbar zu machen.
Zudem können unterschiedliche Anwendungsfälle demonstiert werden, um potentiellen Interessenten
dieser Technologie Anschauungsmaterial zu liefern.

Die Entwicklung eines Protoypen macht bei dieser Masterarbeit Sinn, da am Prototypen:

\begin{itemize}
  \item theoretische Konzepte aufgezeigt und empirisch validiert\footnote{Funktioniert das Konzept richtig?} werden können, und
  \item leicht Anwendungsfälle ausprobiert werden können, um die praktische Tauglichkeit der Softwarearchitektur zu verifizieren\footnote{Ist das System richtig gebaut?}.
\end{itemize}

\section{Anforderungen}

Bei den Anforderungen an den Prototypen kann man schon
konkreter in Richtung Implementierung blicken.

Um die Problemstellungen zu lösen:

Die kleinste Einheit im System ist das \emph{Dokumentenelement}.
Beispiele für Dokumentenelemente sind: Abschnitte, Absätze, Tabellen, Abbildungen, Fußnoten, etc.
\todo{Im Abschnitt "Modelle" den Begriff genauer def und unterteilen -> REF hier her.}

Dokumentelemente sollen in der Lage sein, konkretes "lebendinges" Domänenwissen zu beinhalten.
Das heißt, dass z.B. eine Zeichnung eines chemischen Moleküls im Hintergrund tatsächlich
auf einem formalen Molekülmodell basiert.

Reichhaltige Verweisungen unter den Dokumentelementen sollen möglich sein.
Das heißt, dass z.B. das formale Modell des Moleküls
anderen Dokumentelementen weitere (u.U. berechnete) Informationen bereitstellen kann.

Ein Metamodell definiert die im Dokument vorkommenden Dokumentelemente formal.
Das Dokument selbst soll folglich als Modell (Instanz) aufgefasst werden.

Um die Software benutzbar zu machen:\todo{Besser? Weiche oder Zusatz Anforderungen? Nebenbedingungen / Benutzbarkeit / Bequemlichkeitsfunktionen.}

\begin{itemize}
  \item Es soll ein reaktives System sein, welches sofort auf Eingaben des Benutzers bzw. Veränderungen des Systemzustands reagiert.
  \item Es soll also ein "lebendiges" Dokument werden, d.h. es sollen keine (spürbaren) Kompilierzeiten, um das Dokument zu erstellen, entstehen.
  \item Da es in wissenschaftlichen Dokumenten meist zu komplizierten Verweisungen kommt, müssen diese in jedem Fall konsistent gehalten werden. Es soll daher das Verweisvariablen-Refactoring-Problem\todo{Unschönes Wort!} abgefedert werden.
  \item Es soll ein Einheimischer des WWW werden, d.h. Web Standards sind das Ausgabeformat. Sie übernehmen das Setzen des Dokuments, bieten dem Benutzer eine Editierschnittstelle, ermöglichen Kollaboration und bieten eine ubiquitäre Wissensrepräsentation.
\end{itemize}

Durch einige dieser Anforderungen gewinnen wir implizit einen Projektionseditor und
sogar Potential für ein Dokument "Query Interface"\todo{REF zum entspr Kapitel mit Erklärung}

\section{Idee}

% Idee gesucht um BSc weiterzuentwickeln -> Vorlesung 1. master sem -> MPS/mbeddr -> Projectional Editing. http://confluence.jetbrains.com/display/MPSD31/FAQ
% Und so entwickelten sich diese überlegungen...

Im Vordergrund stand die Idee, meine Bachelorarbeit so weiter zu entwickeln, dass Dokumente
in einem Struktureditor oder Projektionseditor\todo{REF auf Kapitel das ProjEdit genauer erklärt} verfasst werden können und mit domänenspezifischen Dokumentelementen
interagiert werden kann.

In diesem Kapitel wird also kurz die prinzipielle Idee umrissen,
wie man die Problemstellung unter den gegebenen Anforderungen lösen könnte.

Grundsatz der Idee ist, dass jedes Dokumentelement auf ein Aktor abgebildet wird.
Ein Aktor kann Nachrichten senden und empfangen, zudem kapselt er einen Zustand und ein Verhalten.

Aktoren können, ebenso wie ein Dokument, hierarchisch angeordnet werden.
Das heißt ein Aktor kann Kinder und Geschwister haben.
Diese Anordnung ergibt eine baumartige Graphenstruktur, worin ein Aktor
einem Knoten entspricht und eine Referenz\footnote{Über eine solche Aktor Referenz können Nachrichten an andere Aktoren übermittelt werden.} auf einen anderen Aktor einer Kante.

Diese Baumstruktur kann als \emph{abstrakter Syntaxbaum}\footnote{
Englisch: abstract syntax tree. Kurzschreibweise: AST.} (AST) der Dokumentenstruktur aufgefasst werden.
Der AST kann als ein Modell für ein Dokument aufgefasst werden.
Dies wird auf Abbildung \ref{fig.idee} veranschaulicht.
Zudem kann mit Hilfe eines AST ein Struktureditor umgesetzt werden\todo{REF zu Begründungskaptiel}.
Der hier mit den Aktoren umgesetzte AST könnte als "reaktiver AST" bezeichnet werden,
da er dank der Aktoren (quasi gratis) besondere Eigenschaften erhält:

\begin{itemize}
  \item Verteilbarkeit, Fehlertoleranz und massive Parallelität.\\
        AST kann z.B. auf ein Cluster gebracht werden, z.B. zur Kompilierung des Dokuments in "der Cloud"; Anwendung von MapReduce auf Dokument oder Dokumentenserie; Jeder Aktor ist autonom, d.h. z.B. asynchrone Datanbankzugriffe oder schnelle Reaktionszeiten auf Änderungen.
  \item Möglichkeit zum Query Interface ausgebaut zu werden.\\
        Das Dokument bzw. Dokumentelement kann auf Nachrichten reagieren. Beispielsweise zur Aggregation neuer Informationen.
  \item Möglichkeit mit anderen (Aktoren-) Systemen (z.B. Dokumenten) zu interagieren.\\
        Beispielsweise via Akka Remoting Protokoll oder Anbindung an REST-Schnittstellen.
\end{itemize}

\fig{idee}{Modell für ein Dokument. Jeder Aktor (Raute) repräsentiert ein Dokumentelement.
Die Aktoren kennen sich (graue Pfeile) und spannen somit einen Graphen auf.
Die Aktoren können Nachrichten (grüne Pfeile) austauschen, z.B. um Benummerungen aufzulösen.}

\subsection{Szenario}

Hier ist ein kleines Beispiel. In der Auflistung ist jeweils der Aktor und der
Quellcode ausdem der jeweils gesetzte Absatz entstehen soll.
Die mit (meta) markierten Aktoren / Dokumentelemente werden beim Setzen des
Dokuments nicht berücksichtigt.
Auf Abbildung \ref{fig.szenario} sieht man das schlussendlich vom System gesetzte Dokument.

\begin{itemize}

  \item Mathe Aktor "meineFormel" (meta)\\
  \verb|x^2 = 5|

  \item Absatz Aktor\\
  \verb|Das ist ein Text welcher auf ${meineFormel} hinweist.|

  \item CAS Aktor "solved" (meta)\\
  \verb|solved = new MathFormula(${meineFormel}) .solve("x")|\\
  \verb|return_to_document({num: float(solved), formel: solved})|

  \item Absatz Aktor\\
  \verb|Das numerische Ergebnis von ${meineFormel} ist   ${solved.num}, das analytische Ergebnis  ist ${solved.formel}. Jetzt koennte man z.B. mit dem numerischen Ergebnis mit einem anderen Skript weiterrechnen...|

\end{itemize}

\fig{szenario}{Das gesetzte Dokument des Szenario.}


\section{Fragen von wissenschaftlichem Interesse}

Bereiche in denen (wiss.) Fragestellungen durch den Prototypen beantwortet werden können:

\begin{itemize}
  \item Softwaretechnik

  \begin{itemize}
    \item Modellgetriebene Software-Entwicklung\\
          Ist es sinnvoll Dokumente als Modell aufzufassen?
          Wie könnte eine sinnvolle Modellierung von Dokumenten aussehen?
          Gibt es ein gemeinsames Metamodell?
    \item Programmiersprachen, Compilerbau\\
          Kann ein Aktorsystem verwendet werden, um einen abstrakten Syntaxbaum zu implementieren?
          Taugt dieser abstrakte Syntaxbaum als sinnvolle Architekturgrundlage für einen Projektionseditor, und damit auch als Code Generator?
  \end{itemize}

  \item Knowledge Engineering / Management; Semantik, Ontologie\\
        Brauchen wir mehr explizite Semantik innerhalb von Dokumenten?
        Ergeben sich Vorteile, wenn diese Semantik direkt vom Autor transportiert wird?
        Ist es möglich, dass sich Dokumente zu einem gewissen Grad selbst verifizieren\footnote{Ist das Dokument zu einer Spezifikation konform?} und damit konsistenter machen?

  \item Bibliotheks- und Informationswissenschaften\\
        Gibt es eine allgemeingültige Taxonomie für wiss. Publikationen?
\end{itemize}

% Können Aktoren ein als AST eingesetzt werden?
% Was ergibt sich daraus? Architekturell? Was ergibt das für Vor- und Nachteile?
%   - Projektions Editoren (wie macht das MPS?)
%   - Code Generatoren

% Metamodelle in Dokumenten und das Dokument als Modell, macht das Sinn?
%   - Gibt es ein Metametamodell?
%   - Die "was ist zugelassen Matrix"?
%   - Lassen sich Dokumente verifizieren?
%   - Anbindung der domänenspezifischen Editoren

% Brauchen wir mehr explizite Semantik? Was ist der Vorteil wenn sie direkt
% vom Autor transportiert wird? (Und das Dokument / der Editor helfen dabei
% um diesen Vorgang zu erleichtern)
%   - Verifizierbare Dokumente? Das Dokument kann sich in gewisser Weise selbst verifizieren?
%   - Konsistentere Dokumente?

% Was sind wiss. Dokumente?
%   - Sprache == API für Knowledge
%   - Wiss. Dokumente erweitern das Wissensgebiet
%   - Wiss. Dokumente arbeiten selbst immer mit Modellen (allg. Modelltheorie)
%   - Allgemeine Taxonomie wissenschaftlicher Publikationen

% Anwendungsfälle / Use Cases. Ist die Editorarchitektur so flexibel um in den
% verschiedensten Szenarien funktionierende, fast schon maßgeschneiderte Lösungen
% anzubieten?
%   - Warum ist es für Spray ein ideales Dokumentationswerkzeug?
%   - Darstellung und Editierung von UIMA CAS Dokumenten (Annotationen)
%   - ...?


% --------------

\chapter{Theorie}

In diesem Kapitel werden theoretische Konzepte erarbeitet.

\section{Modell und Metamodell}

\begin{quote}
Modellierung ist das uns angeborene Verfahren, das komplexe Universum auf eine überschaubare Welt zu reduzieren. Indem wir sichtbare und unsichtbare Phänomene auf Begriffe abbilden und nur noch mit diesen umgehen, wird die Gesamtzahl der zu betrachtenden Gegenstände beherrschbar[...]
\citep[S.~7]{ludewig}
\end{quote}

Gerade auch in der Wissenschaft spielen Modelle \emph{die} zentrale Rolle, denn
"Das Resultat einer Forschung ist in jedem Falle ein Modell, eine Theorie." \citep[S.~8]{ludewig}
Warum sollte man also nicht den Weg ganz konsequent gehen, und ebenfalls die wissenschaftliche
Dokumentation selbst als Modellierung betrachten?
Warum sollte das Dokument selbst nicht Modelle aus einer Wissenschaft bereitstellen?
Das heißt, dass eine Wissenschaftlerin bzw. ein Wissenschaftler seine Modelle \emph{direkt}
im Dokument verwenden kann?

\subsection{Modellmerkmale}\label{sec.modellmerkmale}

In \citep[S.~9]{ludewig} ist eine griffige Zusammenfassung der drei zwingenden Merkmale
die nach \citep{stachowiak} vorliegen müssen, um als Modell zu gelten,
aufgeführt. Diese werden hier sinngemäß zusammengefasst und durch Abbildung \ref{fig.modell}
veranschaulicht:

\begin{itemize}
  \item Abbildung \\ Ein Modell ist immer ein Abbild eines Originals.
  Die Abbilder können beliebig geartet sein, d.h. das Modell muss dem
  Original äußerlich nicht ähneln. Das Original auf welches sich das Modell
  bezieht, kann neben natürlichen Objekten auch künstlich, geplant oder vermutet sein.
  \item Verkürzung \\ Ein Modell erfasst nicht alle Merkmale des Originals.
  Durch Verkürzung fallen Attribute weg, diese werden übergangen oder präteriert genannt.
  Das Modell kann jedoch zusätzliche Attribute haben, die so im Original nicht vorkommen,
  diese werden überflüssig oder abundant genannt.
  \item Pragmatismus \\ Ein Modell muss einen Sinn haben, um unter bestimmten Fragestellungen das Original ersetzen können.
  Das heißt, es wird das Modell statt des Originals untersucht, um daran die Nützlichkeit für eine Zielgruppe (für wen, wann, wozu?) festzustellen.
\end{itemize}

\fig{modell}{Schematische Zeichnung der Original-Modell-Beziehung. \citep[Entnommen aus][S.~9]{ludewig}}

\subsection{Modell eines Dokuments}

Bevor ein passendes Modell für Dokumente gefunden werden kann,
muss man sich bewusst sein dass es dem Abbildungsmerkmal,
Verkürzungsmerkmal und dem pragmatischen Merkmal,
welche in Kapitel \ref{sec.modellmerkmale} beschrieben sind, genügen muss.

Das Original ist in jedem Fall ein gesetztes statisches Dokument, z.B.
ein auf Papier gedrucktes Buch oder ein (wiss.) Bericht im PDF-Dateiformat.

Dort interessieren uns als Autor in erster Linie aber nur die wirklich inhaltstragenden
Attribute des Originals.
Auf einer höheren Abstraktionsebene entsprechen diese den Dokumentelementen\todo{Def Dokelem in ein Glossar?}, wie z.B.
Abschnitte, Absätze, Abbildungen etc.
Im Falle von z.B. Abschnitten ist nur der Titel maßgeblich, die Benummerung kann
auch erst später (durch Berechnung) hinzugefügt werden.
Das heißt hier wäre der Titel ein Attribut welches
vom Original in das Modell abgebildet wird; die Benummerung wäre jedoch ein abudantes
Attribut welches erst innerhalb des Modells erstellt wird.
Layoutinformationen, Schriftarten oder Papiersorte spielen dafür keine Rolle und
können somit weggelassen werden.

Wenn der Autor an seinem Dokument arbeitet, dann stets über das Modell,
wo er sich ausschlißlich auf die Dokumentelemente konzentrieren kann.
Das Modell kann präskriptiv sein, d.h. aus dem Modell kann wieder ein Original entspringen.

Hier wird der \emph{abstrakte Syntaxbaum} als Modell für das Dokuments dienen,
indem jedes Dokumentelement aus ein Knoten des abstrakten Syntaxbaum aufgefasst wird.
Mehr zum abstrakten Syntaxbaum in Abschnitt \ref{sec.ast}.

\subsubsection{Beweis}
\paragraph{Abbildungsmerkmal}
Der abstrakte Syntaxbaum („das Modell“) ist z.B. ein Abbild eines
gedruckten Buches, da Dokumentelemente als Knoten im Syntaxbaum vorkommen.
\paragraph{Verkürzungsmerkmal}
Nur die Attribute aus dem Original werden modelliert, die den maßgeblichen Inhalt des
Dokuments transportieren (z.B. Text). Diese Inhalte werden als Dokumentelemente
modelliert.
\paragraph{Pragmatischen Merkmal}
Der Autor greift auf das Modell zurück, um daran die herausgelößten und essentiellen
Dokumentelemente zu untersuchen bzw. zu manipulieren.

Alle Bedingungen für den Modellbegriff nach \citep{stachowiak} sind erfüllt. $\blacksquare$

\subsection{Metamodellbegriff}\label{sec.metamodellbegriff}

\begin{quote}
Werden Modelle und Modellbildung selbst zum Gegenstand der Modellierung, so spricht man von Metamodellen. \citep[S.~1]{stra}
\end{quote}

\citep{stra} hat versucht den Metamodellbegriff anhand der Sprachstufentheorie der Logik,
durch Übertragung auf die Modellierungswelt, zu prägen.
\citep[S.~1]{stra} erklärt, dass nach \citep{buehler} die Sprache drei Funktionen leistet:
(1) Darstellung von Sachverhalten, (2) Appell zur Verhaltenssteuerung und
(3) Ausdruck von Gefühlen.
Für den Metamodellbegriff ist jedoch nur die Darstellungsfunktion
interessant.

Sprache stellt "ein mögliches Instrument zur Darstellung von Modellen" dar.

\citep[S.~1]{stra} führt fort, dass in der Logik üblicherweise zwischen Objektsprache und Metasprache
unterschieden wird.
Die Objektsprache ist Gegenstand der Untersuchung.
In der Metasprache erfolgt die Untersuchung.
Da die Metasprache selbst auch wieder Gegenstand einer Untersuchung werden kann,
ist dieses Prinzip rekursiv anwendbar.
Um endlose Rekursion zu vermeiden, sollte als oberstes Glied der Kette ein selbstbeschreibendes
Metamodell stehen. Beispielsweise die Meta Object Facility (MOF) der OMG\footnote{Definiert in
ISO/IEC 19508.} geht so vor, um endlose Meta-Rekursionen zu vermeiden.

Wird "die Sprachstufentheorie auf die Modellbildung [...] übertragen, so" kann
im einfachsten Fall ein Metamodell "als ein Modell eines Modells" beschrieben werden.

\begin{quote}
Wird die Objektsprache, in der das Modell der untersten Stufe formuliert ist, abgebildet in einem Beschreibungsmodell, so handelt es sich um ein Metamodell.\citep[S.~3]{stra}
\end{quote}

"Beschreibungsmodelle dienen der systematischen Beschreibung des betrachteten Gegenstandsbereiches und bestehen aus ausschließlich deskriptiven Satzsystemen."
Das heißt, ein Beschreibungsmodell ist ein Modell welches so forumliert wird, dass es
ein Original anschaulich macht bzw. Eigenschaften des Originals sprachlich spezifiziert.

Abbildung \ref{fig.metamodellbegriff} veranschaulicht den Zusammenhang von
Modell und dessen Metamodell.

\fig{metamodellbegriff}{Der sprachbasierte Metamodellbegriff.
Die "Miniwelt" entspricht dem Original. \citep[Grafik entnommen aus][S.~3]{stra}}


\subsection{Metamodell des Dokumentmodells}\label{sec.meta}

Auf Abbildung \ref{fig.docmodell} ist das eigentliche Modell visualisiert.
Dieses soll vom Metamodell beschrieben werden.

\fig{docmodell}{Das hier verwendete Dokumentmodell.
Das Dreieck symbolisiert die Wurzel.
Die Rauten symbolisieren jeweils einen Aktor bzw. ein Dokumentelement.
Die stark gezeichneten Pfeile symbolisieren das erste Kind,
die gestrichelte Linie symoblisiert die zugehörigen anderen Kinder.
Die schwach gezeichneten Pfeile symbolisieren die nächstes Geschwister.
Dadurch wird die Dokumenthierarchie aufgespannt.}

Abbildung \ref{fig.metamodell} zeigt das Modell welches das Dokumentmodell beschreibt,
also das "Metamodell".
In der Mitte liegt der Basis Aktor, dieser hält Referenzen zu seinem ersten Kind
und zu seinem unmittelbaren Geschwister.
Zudem hält der Basis Aktor Inststanzen aller verfügbaren Dokumentelemente,
wovon jedoch immer nur eine \emph{aktiv} ist.
Welche Dokumentelemente verfügbar sind, wird vom Programmierer spezifiziert -- dazu
muss er ein Scala Trait (entspricht einem Interface) implementieren und dem
Basis Aktor bekannt machen.
Man kann sagen, dass er das Metamodell an dieser Stelle (gewollt) verändert.
Der Wurzel Aktor hält nochmals alle Topologieinformationen, daher kennt er
alle im System vorhandenen Basis Aktoren.
Jeder Basis Aktor kennt auch seine zugehörige Wurzel, welche er bei ggf. anstehenden
lokalen Topologieveränderungen benachrichtigen muss.

\fig{metamodell}{Das Metamodell des Dokumentmodells.}

Genügt das hier besprochende Metamodell dem in Abschnitt
\ref{sec.metamodellbegriff} behandelten Metamodellbegriff?

Die Besonderheit bei dem hier entstandenen System ist, dass das
Modell gleichzeitig die Sprache ist, in der es modelliert wird.
Dies ist möglich, da das System als Projektionseditor designed ist.
Die Objektsprache in der das Modell formuliert ist,
entspricht somit quasi der Projektion\todo{Erst Projektion beschreiben?}
~die direkt aus dem abstrakten Syntaxbaum entspringt.
Man könnte von einem Modell-Objektsprache-Dualismus sprechen --
es ist gleichzeitig Modell und Objektsprache, je nach Betrachtungspunkt.

Das Modell indem wiederum die Objektsprache modelliert ist, muss ein Beschreibungsmodell sein,
damit dies einem Metamodell entspricht.
Das hier vorgestellte "Metamodell" spezifiziert die Eigenschaften des Originals
(dies geschieht in den einzelnen Dokumentelementen)
und die prinzipielle Struktur (anschaulich gemacht durch Wurzel/Basis Aktor)
des abstrakten Syntaxbaumes.
Der betrachtete Gegenstandsbereich ist der abstrakte Syntaxbaum, dieser in seiner 
Gesamtheit ist wiederum das Modell des Dokuments.
Auf Abbildung \ref{fig.metamodellschema} ist nochmals eine Übersichtsgrafik der Zusammenhänge von
Modell und Metamodell.
Somit genügt es dem Metamodellbegriff. $\blacksquare$

\fig{metamodellschema}{Übersicht der Zusammenhänge des Dokumentmodells und Dokumentmetamodells
in Anlehnung an Abbildung \ref{fig.metamodellbegriff}.
Die erweiterte Backus-Naur-Form (EBNF) kann als Metametamodell dienen --
denn mit EBNF können Programmiersprachen beschrieben werden und zudem ist EBNF
in der Lage sich selbst zu beschreiben.}

% Templates für die Projektionen (deklariert auf der gleichen Ebene wie das Metamodell?)...
% Das Metamodell für die Projektionen sind die Templates, z.B. Mustache-HTML + CSS + JS ...


\section{Semiotik: Syntax, Semantik, Pragmatik, Sigmatik}

\subsection{Domäneneditoren}


\section{Abstrakter Syntaxbaum}\label{sec.ast}

In diesem Abschnitt werden die prinzipiellen Eigenschaften von abstrakten Syntaxbäumen,
kurz AST, beschrieben.

Laut \citep{dragonbook} ist der AST eine Datenstruktur, die von einem Übersetzer als
Zwischenrepräsentation eines Quellcodes generiert wird.
Er repräsentiert die hierarchische syntaktische Struktur eines Programms.
Aus einer solchen Zwischenrepräsentation wird schlussendlich das Zielprogramm generiert.

Wärend der Syntaxanalyse (parsing) werden Syntaxbaum-Knoten erstellt, welche wiederum
signifikate Programmkonstrukte repräsentieren.
Die Kinder des Knoten sind die bedeutungstragenden Komponenten des Konstrukts.
Beispielsweise (s. Abb. \ref{fig.ast}): Gegeben ist ein AST für einen Ausdruck (expression),
dann repräsentiert jeder innere Knoten einen Operator und die Kinder des Knoten
sind die Operanden.
Man beachte jedoch, dass Syntaxbäume für beliebige Konstrukte erstellt werden können
und nicht auf Ausdrücke beschränkt sind.
Jedes Konstrukt ist durch einen Knoten repräsentiert, dessen Kinder semantisch
bedeutungsvolle Komponenten des Konstruktes sind.
Durch fortschreitende Analyse können Informationen vom Übersetzer
zu den Knoten als Attribute hinzugefügt werden. (ebd.)

\fig{ast}{Abstrakter Syntaxbaum für den Ausdruck $9-5+2$. \citep[Entnommen aus][S.~70]{dragonbook}}

\subsection{Allgemeine Implementierung}

Wenn ein Operator, also ein innerer Knoten, beliebig viele Operanden, also Kinder des Knoten,
haben darf, spricht man von einem
\emph{n-stelligen}\footnote{Der Begriff Stelligkeit (engl. arity, „Artigkeit“)
steht für die Anzahl der Argumente einer Verknüpfung, einer Abbildung bzw. eines
Operators oder in der Informatik für die Parameteranzahl von Funktionen,
Prozeduren oder Methoden. (Aus \url{https://de.wikipedia.org/wiki/Stelligkeit})}
bzw. n-ary AST. \citep{edwards}
Eine solche Struktur ist auf Grafik \ref{fig.astimpl} veranschaulicht.

\fig{astimpl}{Generellste Implementierung eines AST. \citep[Entnommen aus][]{edwards}}

\subsection{Übertragung auf den Prototypen}

Die zentrale Struktur des hier vorgestellten Prototyps ist ebenfalls ein abstrakter Syntaxbaum.
Das ist legitim, da Syntaxbäume beliebige Konstrukte repräsentieren können.
Jedoch handelt es sich nicht ausschließlich um eine Datenstruktur, da Aktoren als die
Baum-Knoten fungieren und Aktoren neben der reinen Datenhaltung auch auf Nachrichten reagieren können.
Man könnte quasi davon sprechen, dass der abstrakte Syntaxbaum in dem hier vorgestellten System
eine „lebendige Datenstruktur“ ist.
Das kann dahingehend von Vorteil sein, da der AST dadruch befähigt ist,
selbstständig eine Analysephase durchzuführen.

In einer solche Analysephase werden u.U. weitere Informationen zu den Knoten hinzugefügt.
Beispiel: Eine Hierarchie von Kapiteln kann während der Analyse die jeweils richtige
Benummerung ermitteln und jeder Aktor (also Knoten) speichert sich diese Benummerung
intern als Attribut ab.

Der Basis Aktor aus Abbildung \ref{fig.metamodell} entspricht quasi 1:1 der
generellen Implementierung aus Abbildung \ref{fig.astimpl}.
Das hier vorgestellte Metamodell (s. Abschnitt \ref{sec.meta}) beschreibt also eindeutig einen AST.
Die Knoten entsprechen den Aktoren, welche wiederum die einzelnen Dokumentelemente
des Dokuments repräsentieren.
Dieser AST, gesehen als Programmsyntax, beschreibt somit den hierarchischen Aufbau des Dokuments.

Die inneren Knoten, die z.B. Operatoren repräsentieren können, entsprechen hier
hierarchiebildenden oder gliedernden Elementen.
Diese können (müssen aber nicht) im Dokument sichtbar sein.
Beispiele dafür sind z.B. Kapitel, Abschnitte oder die Titelei.
Die Kinder dieser Knoten sind bedeutungsvolle Komponenten für den Knoten dahingehend,
dass sie entweder weiter die Hierarchie des Dokuments aufspannen und somit das
Dokument weiter gliedern oder im Falle von Blättern, die eigentlich inhaltstragenden
Elemente sind.
Die Blätter müssen auf jeden Fall im Dokument sichtbar sein.
Beispiele dafür sind z.B. Absätze oder Abbildungen.


\section{Dokumentstruktur Matrix}


\section{Ontologie/Taxonomie wissenschaftlicher Publikationen}


\section{Struktureditoren}

Oder ist das eine Technologie?
Struktureditoren oder Projektionseditoren oder projectional editors...

\fig{parser-vs-projectional}{\emph{Parserbasierte Editierung} (links) verglichen mit \emph{projektionsbasierter Editierung} (rechts). Grafiken aus \citep{voelter} entnommen.}


\chapter{Anwendungsfälle}

\section{Spray Modell-Dokumentationstool}

Werkzeug zur technischen Dokumentation von Spray (Software) Modellen.
Also ein Doku Tool für modellgetriebene SW Entwicklung.

\section{UIMA CAS Editor}

Zum störungsfreien Anzeigen von Annotationen.
Rekonstruktion eines Originaldokuments.
Originaldokument um neue Informationen anreichern.
Ein Dokument im Volltext wieder editierbar machen.

\section{Erstellung wissenschaftlicher Publikationen}

Könnte sich als Werkzeug zum erstellen wiss. Arbeiten etablieren.
Bei den MINT Wissenschaften.
Editor kann beim Erstellung assisiteren, z.B. ein Paragraph kann automatisch
eine Volltextsuche in Literaturbeständen durchführen und Vorschläge machen,
falls vermutet wird ein Zitat aus einer Quelle gefunden zu haben.
Quelle kann dann automatisch mit allen nötigen nachweisen auf magische weise
hinzugefügt werden.
Szenario von Spezialelementen mit Domänenwissen (z.B. Chemie).


\chapter{Entwicklung des Prototypen}


\section{Basiskonzepte}

\subsection{Referenzierungen}

Referenzierungen angereichert mit (Programmcode) Ausdrücken.
Expression returnt eine Scala Klasse auf die toString angewendet wurde,
aber diese Klasse kann auch ihren Typ verraten so dass dieser direkt
als Annotation der Referenz verwendet werden kann.

2 Modelle:

(1) Aktor hat content String mit Code (Expression) der zu Aktor-Referenzen zeigt

(2) Aktor hat Kind-Aktoren als "content" und die Kinder enthalten Code-Expressions
    oder reinen Text.

UMIA zu Scaltex:
zu (1): Wenn Text gefunden einfach an content anhängen, wenn spezielle
Annotation gefunden dann entsprechenden Aktor erstellen (unsichtbar) und
eine \verb|${ Aktor-UUID.gewünschte_repräsentation}| darauf erstellen und an
den content-String anhängen.


\section{Verwendete Technologien}

html5: contenteditable

\subsection{Ketcher}

\subsection{Spray}

\subsection{UIMA}

\subsection{Akka Toolkit}

\subsection{Xitrum Server Framework}

Alle Frameworks werden noch aktiv entwickelt und gepflegt.

Untersuchte Scala Frameworks:

Spray.io Version 1.2.0
Unterstützt keine Websockets, ist erst für die Zukunft geplant.
Entwickelt seit 2011. (siehe Changelog)
Im Hintergrund (als Server) läuft pures Akka?
\url{http://spray.io/}

Play Framework Version Version 2.2.2
Sehr vielversprechend und stabil mit großer Entwicklergemeinde.
Jedoch läuft der Scala Interpreter hier nicht, da eine extra VM gestartet
wird, was durch das play sbt plugin geschuldet ist.
Entwickelt seit 2007. (Wikipedia - besser Quelle suchen)
Im Hintergrund läuft JBoss Netty.
\url{http://www.playframework.com/}

Socko Web Server Version 0.4.1
Interessante Funktionen, aber für mich eine schwierige und umständliche API.
Entwickelt seit 2012? (Nur ungefährt aus Github Version 0.1)
Im Hintergrund läuft JBoss Netty.
\url{http://sockoweb.org/}

Xiturm Version 3.5
Mit Abstand die beste und schönste API und wird schon seit 2010 aktiv entwickelt.
Wird laut Author in echten Projekten schon erfolgreich eingesetzt.
Die Dokumentation ist auch recht umfangreich und gut verständlich.
Im Hintergrund läuft JBoss Netty.
\url{http://ngocdaothanh.github.io/xitrum/}
About: \url{https://groups.google.com/forum/#!topic/xitrum-framework/Jx6bwGciNR0}


\section{Abstrakter Syntax Baum}

Jeder Knoten im AST ist ein Aktor. Der AST entspricht einem gerichteten Graph.
Zeigen, dass es ein Baum-Graph ist!

\url{http://de.wikipedia.org/wiki/Abstract_Syntax_Tree}


\subsection{Algorithmus: Aufdecken der Kapitel Benummerung im gerichteten Graph}

Aufdecken der Section Nummern im gerichteten Graph.

Gerichteter Graph G: a -> b -> x -> c
a,b,c sind Sections
x ist keine Section
N = Knoten
E = Kanten

a schickt die Nachricht "Durchzählen(1)" durch G.

b erhält eine Nachricht von a.
b erhöht Durchzählen um 1 auf Durchzählen(2).
b setzt seinen eigenen Nummerzähler auf Durchzählen(2).
b schickt "Druchzählen(2)" weiter durch den Graph.

x reicht die "Durchzählen" Nachricht weiter, ohne Aktion.

c erhält eine Nachricht die von a und b (etc.) bearbeitet wurden.
c erhöht Durchzählen um 1 auf Durchzählen(3)
c setzt seinen eigenen Nummerzähler auf Durchzählen(3).
Da c keinen Nachfolger mehr hat, kann nichts weitergeleitet werden.

Damit werden maximal |E| Nachrichten benötigt, um für jeden Section Knoten
die korrekte Nummer zu bestimmen.


Bei SubSection und SubSubSection einfach mit der
Nachricht Durchzählen(1, true, 1, false, 1, false) beginnen.
Wobei die Boolwerte anzeigen, welcher Wert zuletzt aktualisiert wurde.
So kann jede SubSection oder SubSubSection herausfinden, zu welcher
übergeordneten Section/SubSection sie gehört.

a ! Durchzählen(1, true, 1, false, 1, false)
b ! Durchzählen(2, true, 1, false, 1, false)
aa ! Durchzählen(2, false, 1, true, 1, false)
bb ! Durchzählen(2, false, 2, true, 1, false)
aaa ! Durchzählen(2, false, 2, false, 1, true)
bbb ! Durchzählen(2, false, 2, false, 2, true)
c ! Durchzählen(3, true, 1, false, 1, false)
...

Das ist ein recht natürlicher Ansatz, um die Nummerierungen zu bestimmen.
Auf diese Art können Section, SubSection und SubSubSection gleichzeitig
mit einer einzigen Nachrichtenkette aktualisiert werden.
Der Aufwand bleibt also bei maximal |E| Nachrichten.


\chapter{Ergebnisse und Analyse}

Wo siedelt sich das neue Autorensystem an? (Zwischen Latex und Word?)

\section{Validierung der theoretischen Konzepte}

\section{Verifikation der Anwendungsfälle}


\chapter{Fazit}


\chapter{Ausblick}

Geschäftsmodell: Marktplatz für "Spezialelemente" und Services wie z.B. Literatur Volltextrecherche + autom. Quellenauflösung etc.? Offene Platform um Papers / Arbeiten reviewen zu lassen von anderen Autoren -> Zuweisung von DOIs, Reviewer können Geld bekommen, Wenn zitiert wird kann man Geld bekommen, Autoren/Reviewer haben Repurtationssystem ...

Elemente z.T. als Docker Container?


% http://tex.stackexchange.com/questions/49643/making-appendix-for-thesis
